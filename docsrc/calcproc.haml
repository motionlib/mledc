!!!
%head
  %meta{ charset:"utf-8" }
  %script{ src:"https://polyfill.io/v3/polyfill.min.js?features=es6" }
  %script{ id:"MathJax-script", async: 'async', src:"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"}
  %script{ src:"https://www.gstatic.com/charts/loader.js"}

  :css
    body{
      margin:1em;
    }
    p, table {
      font-size:10pt;
    }
    .right{
      text-align:right;
      padding-right:1em;
    }
    h1{
      border-top : solid 2px #bbb;
      border-left : solid 16px #bbb;
      background-color: #f8f8f8;
    }
    h2{
      border-top : solid 2px #bbb;
      border-left : solid 8px #bbb;
      background-color: #f8f8f8;
    }
    h3{
      border-top : solid 1px #bbb;
      border-left : solid 4px #bbb;
      background-color: #f8f8f8;
    }
    h4{
      background-color: #f8f8f8;
    }
    table{
      margin-left:2em;
    }
    p{
      margin-left:1em;
    }
    p.math{
      margin-left:2.5em;
    }
    tr:nth-child(even){
      background:#F2F2F2;
    }
    tr:nth-child(odd){
      background:#d8d8d8;
    }
    th,td{
      padding:5px;
    }
    .barchart{
      padding: 1em;
      margin: 1em;
      background-color: #eee;
      border: solid #888 2px;
    }
    #barchart_material{
      float:right;
    }

  :javascript
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
    google.charts.load('current', { 'packages': ['bar'] });
    google.charts.setOnLoadCallback(drawChart);
    function drawChart() {
      var dataM = google.visualization.arrayToDataTable([
        ['', 'mledc', 'crc32', 'fletcher32'],
        ['16bytes × 49152 times', 175.38, 832.933, 138.619],
        ['31bytes × 25368 times', 308.42, 1052.48, 148.774],
        ['64bytes × 12288 times', 393.859, 1439.83, 127.1],
        ['127bytes × 6192 times', 494.835, 1600.48, 138.886],
        ['256bytes × 3072 times', 539.442, 1693.1, 167.451],
      ]);

      var dataR = google.visualization.arrayToDataTable([
        ['', 'mledc', 'crc32', 'fletcher32'],
        ['16bytes × 49152 times', 1408.02, 6101.73, 959.274],
        ['31bytes × 25368 times', 1445, 6855.69, 812.502],
        ['64bytes × 12288 times', 2120.37, 6704.91, 1515.26],
        ['127bytes × 6192 times', 2091.78, 6639.39, 1474.95],
        ['256bytes × 3072 times', 2009.69, 6606.32, 1366.57],
      ]);

      var draw = function (data, pc, id) {
        var options = {
          hAxis: {
            format: "decimal",
          },
          backgroundColor: "#eee",
          bar: { groupWidth: "80%" },
          bars: 'horizontal', // Required for Material Bar Charts.
          axes: {
            x: {
              0: { side: 'top', label: 'Execution time in μs(' + pc + ')' },
            }
          },
        };
        var chart = new google.charts.Bar(document.getElementById(id));
        chart.draw(data, google.charts.Bar.convertOptions(options));
      };

      draw(dataM, "MacBook Pro", "barchart_mac");
      draw(dataR, "Raspberry Pi 3B+", "barchart_rp");
    }  
  %title
    mledc
%body
  #barchart_material
    #barchart_mac.barchart
    %hr
    #barchart_rp.barchart
  %h1 計算量
  %p
    計算内容が簡単な上にメモリアクセスが少ないので、計算量は CRC32 と比べるとだいぶ少ないが、fletcher32 と比べると遅い。
    %br
    MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports) だと mledc は fletcher32 にだいぶ負けているが、 Raspberry Pi 3B+ ではそれほど大きな差はない。
  %h1 誤り検出性能
  %p
    乱数で 1〜255 バイトのデータ列を作り、そこにノイズを付加し、約1.5億回の試行を行った。
    %br
    誤り検出に失敗した回数は下表の通り：
  %table
    %tr
      %th 誤り検出符号
      %th 誤り検出失敗回数
      %th 誤り検出失敗率(百万分率)
      %th 誤り検出失敗率の逆数
    -[["mledc", 155374419,5],["crc32", 155374424,0],["fletcher32", 155374306,118]].each do |name,ok,ng|
      %tr
        %th=name
        %td.right=ng
        %td.right="%.4f" % (ng*1e6/(ok+ng))
        %td.right=( ng==0 ? "n/a" : ((ok+ng)/ng).round(-4).to_j )
  %p
    crc32 は流石。
    %br
    mledc は 5ミス。fletcher32 と比べると20倍ぐらい良かった。

  %h1 計算内容
  %h2 データの取得
  %p
    データは 2byte ずつ取得する。端数がある場合は末尾にもう 1byte ゼロがあることにする。
    %br
    →
    %code 0x12, 0x34, 0x56
    と
    %code 0x12, 0x34, 0x56, 0x00
    の区別はつかない。
  %p
    というわけで、入力バイト数の半分(端数切り上げ)個の、符号なし16ビット整数が手に入る
  %p

  %h2 計算
  %h3 計算に必要な定数
  %p
    以下の定数を必要とする。
  %table
    %tr
      %th 変数名
      %th 説明
      %th 補足
    %tr
      %td
        %code init
      %td 初期値
      %td 2進数で0と1がいい感じに混ざっている値がいいんじゃないかと思う。
    %tr
      %td
        %code mul
      %td 乗数
      %td
        2進数で0と1がいい感じに混ざっている
        %b 素数
        がいいんじゃないかと思う。
  %h3 計算に必要な変数
  %p
    実質的に 32bit 符号なし整数1個。この変数の名前を
    %code c
    とする。
  %h3 初期化
  %p
    %code c
    を
    %code init
    で初期化する
  %h3 更新
  %p
    符号なし16bit整数の入力データ
    %code x
    を受け取り、以下の計算をする:
  %p.math
    $c ← rol(c) \times mul + x$
  %p
    関数 $rol$ は、1bit 左ローテート。数学っぽく書くと以下の通り:
  %p.math
    $ rol(x) = mod( \lfloor x \times 2 + x \div 2^{31} \rfloor,\: 2^{32} ) $
  %p
    関数 $mod$ は剰余関数。数学っぽく書くと以下の通り:
  %p.math
    $ mod(a,\: n) = a - n \lfloor a \div n \rfloor $
  %h2 誤り検出性能
  %p
    正直言って、よくわからない。
  %p
    1〜255 バイトまでのデータを乱数で作り、1〜32bit ぐらいのノイズを付加し、誤り検出符号の値が変わるかどうか、1200万回ぐらい調べたが、全てのケースでエラーを検出した。
  %p
    実験結果は悪くないので、そんなに酷いってことはないわけだけど、どれほど有意義な計算なのかはわからない。
